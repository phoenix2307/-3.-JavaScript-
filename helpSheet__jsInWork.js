// classList МЕТОДЫ

const btns = document.querySelectorAll('button');

// console.log(btns[0].classList.length); // количество классов у элемента
// console.log(btns[0].classList.item(2));  // обращение к классу по его индексу в списке

btns[1].classList.add('red'); // добавить класс
// btns[0].classList.remove('blue'); // удалить класс
// можно добавлять или удалять несколько классов одновременно. Прописывать через запятую

// btns[0].classList.toggle('blue'); // переключатель состояния класса 
//(то есть если он есть, то он удаляется, если нет такого класса - то добавляется)

console.log(btns[1].classList.contains('red')); // проверяет наличие класса у элемента, возвращает true или false

// if (btns[1].classList.contains('red')) {
//   console.log('класс red');
// }

btns[0].addEventListener('click', () => {
  if (!btns[1].classList.contains('red')) {
    btns[1].classList.add('red');
  } else {
    btns[1].classList.remove('red');
  }
  // это все можно реализовать с помощmю toggle, но лучше использовать вот такой способ с if else
  // btns[1].classList.toggle('red');
});

// ДЕЛЕГИРОВАНИЕ //
/*
Обработчик события вешается на родителя. При этом есть два плюса:
1. позволяет влиять на все элементы в родителе даже, если они будут добавляться динамически
2. Обработчик вешается только на один элемент-родитель, нет нужды цеплять обработчик на детей

*/
const wrapper = document.querySelector('.btn-block'); // обращаемся к родителю, куда будем кидать делегирование
wrapper.addEventListener('click', (event) => { //задаем условие для того,
  // чтобы событие срабатывало только при клике по button
  if (event.target && event.target.matches('button.red')) {
    /*
    у event.target есть интересный метод matches() - можно добавить какое-то услоыие,
    при котором будет выполнятсяя событие. Например, перечень класов, которые должен иметь элемент
    */
    console.log('Hello');
  }
});


const btn = document.createElement('button'); // создать новую кнопку
btn.classList.add('red'); // Присвоить необходимый класс элементу
wrapper.append(btn); // добавить элемент на страницу

//
////////////////////////////////// TimeOut // Анимация //////////////////////
//
// setTimeout - позволяет вызвать функцию один раз через определённый интервал времени
// setInterval - позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени
// let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
/*Параметры:
func|code
Функция или строка кода для выполнения. 
Обычно это функция. По историческим причинам можно передать и строку кода, но это не рекомендуется.
delay
Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.
arg1, arg2…
Аргументы, передаваемые в функцию

//////////// Рекурсия в setTimeout 
Это лучше чем использование интервала - можно контролировать паузы между ф-циями

вместо кода:
let timerId = setInterval(() => alert('tick'), 2000);

let timerId = setTimeout(function tick() {
  alert('tick');
  timerId = setTimeout(tick, 2000); // (*)
}, 2000);

Итого:

Методы setInterval(func, delay, ...args) и setTimeout(func, delay, ...args) позволяют 
выполнять func регулярно или только один раз после задержки delay, заданной в мс.

Для отмены выполнения необходимо вызвать clearInterval/clearTimeout со значением, 
которое возвращают методы setInterval/setTimeout.

Вложенный вызов setTimeout является более гибкой альтернативой setInterval. Также 
он позволяет более точно задать интервал между выполнениями.

Планирование с нулевой задержкой setTimeout(func,0) или, что то же самое, 
setTimeout(func) используется для вызовов, которые должны быть исполнены как можно скорее, 
после завершения исполнения текущего кода.

Браузер ограничивает 4-мя мс минимальную задержку между пятью и более вложенными вызовами setTimeout, 
а также для setInterval, начиная с 5-го вызова.

пример интервала с заданным количеством раз:

const btn = document.querySelector('.btn');
let timerId;
let i = 0;

btn.addEventListener('click', () => {
  // timerId = setTimeout(logger, 1000);
  timerId = setInterval(logger, 500);

});

function logger() { // отслеживаем сколько раз повторился интервал
  if (i === 3) {
    clearInterval(timerId);
  }
  console.log('some text');
  i++;
}

Пример рекурсии:

let id = setTimeout(function log() {
  console.log('Hello Alex');
  id = setTimeout(log, 500);
}, 500);


Пример анимации:

const btn = document.querySelector('.btn');

function myAnimation() {
  const elem = document.querySelector('.box');
  let pos = 0; // стартовая позиция нашего элемента
  //нужна ф-ция, которая будет запускаться с интервалом и меняь позицию нашего элемента

  const id = setInterval(frame, 10);

  function frame() {
    if (pos == 300) { //точка остановки элемента
      clearInterval();
    } else {
      pos++;
      elem.style.top = pos + 'px';
      elem.style.left = pos + 'px';
    }
  }
}
btn.addEventListener('click', myAnimation);

///////// DATE (Работа с датами) /////////


new Date()
Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется таймстамп (англ. timestamp).
Из таймстампа всегда можно получить дату с помощью new Date(timestamp) и преобразовать существующий объект Date в таймстамп, используя метод date.getTime() (см. ниже).

Датам до 1 января 1970 будут соответствовать отрицательные таймстампы, например:
// 31 декабря 1969 года
let Dec31_1969 = new Date(-24 * 3600 * 1000);
console.log( Dec31_1969 );

getTime()
Для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.

** *** *** Установка компонентов даты
Следующие методы позволяют установить компоненты даты и времени:

setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)

Предположим, нам требуется увеличить дату «28 февраля 2016» на два дня. В зависимости от того, високосный это год или нет, результатом будет «2 марта» или «1 марта». Нам об этом думать не нужно. Просто прибавляем два дня. Объект Date позаботится об остальном:

let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);

alert( date ); // 1 Mar 2016

******** Получить дату по прошествии заданного отрезка времени. Например, получим дату «спустя 70 секунд с текущего момента»:

let date = new Date();
date.setSeconds(date.getSeconds() + 70);

alert( date ); // выводит правильную дату

*********
Date.now()
Если нужно просто измерить время, объект Date нам не нужен.

Существует особый метод Date.now(), возвращающий текущую метку времени.

Семантически он эквивалентен new Date().getTime(), однако метод не создаёт промежуточный объект Date. Так что этот способ работает быстрее и не нагружает сборщик мусора.

Данный метод используется из соображений удобства или когда важно быстродействие, например, при разработке игр на JavaScript или других специализированных приложений.

Вероятно, предыдущий пример лучше переписать так:

let start = Date.now(); // количество миллисекунд с 1 января 1970 года

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now(); // заканчиваем отсчёт времени

alert( `Цикл отработал за ${end - start} миллисекунд` ); 
ВАЖНО: вычитаются числа, а не даты
//

******************************

Пример получение крайних точек времени события и вывод их разницы
let start = new Date();

for (let i = 0; i < 1000; i++) {
  console.log(i);
}
let end = new Date();
console.log(`Цикл отработал за ${end - start} милисекунд`);

Итого

Дата и время в JavaScript представлены объектом Date. Нельзя создать «только дату» или «только время»: объекты Date всегда содержат и то, и другое.

Счёт месяцев начинается с нуля (да, январь – это нулевой месяц).

Дни недели в getDay() также отсчитываются с нуля, что соответствует воскресенью.

Объект Date самостоятельно корректируется при введении значений, выходящих за рамки допустимых. Это полезно для сложения/вычитания дней/месяцев/недель.

Даты можно вычитать, и разность возвращается в миллисекундах. Так происходит, потому что при преобразовании в число объект Date становится таймстампом.

Используйте Date.now() для быстрого получения текущего времени в формате таймстампа.

*/